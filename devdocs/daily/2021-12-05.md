# 2021-12-05

Thoughts on goals and multiple movers.

- The Mover Queue
	- The game loop needs to maintain a mover queueâ€”the relevant mobiles in the order in which they get to move.
	- The mobile at the head of the queue is the _current mover_.
	- A mover's goals are assigned when it becomes the _current mover_.
	- Then, those goals are executed until there are none, and the next mover gets to move.
- Player clicks and the Mover Queue
	- Player clicks are ignored if the current mover is not controlled by the player.
	- The game loop stops and waits for a user click when a player-controlled mobile becomes the current mover.
	- Eventually, player clicks will be able to cancel a player-controlled mobile's current goals and redirect it.
- Player characters move individually, one at a time.  Should monsters all move at the same time?
	- Watching turn-based strategy games like Fire Emblem, it gets boring waiting for all of the bad guys to move.
	- It might be more entertaining if all of the monsters move simultaneously.
	- If I have an initiative stat of some kind, monsters might get grouped by where they sort: fast monsters, player character A, slower monsters, player character B, slowest monsters.
	- NPCs, to the extent that they move about, should move all together out of combat, but individually in combat.

Thoughts on Systems.

- In an ECS, a system is basically a function.
- In my world, it's going to be using lambdas to assign behavior to various mobiles, etc.  The relevant lambdas are also part of the system.
- All functions need access to the global state.
- The global state consists of I don't know what all, yet, but certainly includes the `Region`, which owns the Entities Table; and the `Region` is owned and controlled by the App.
- How to modularize systems while retaining access to the state?
	- Inner trait classes defined as part of the App
	- External classes created with a reference to the App
	- Each defines the methods required by the game loop, and any needed functions to be passed as lambdas.